# computer structure
# CPU
# RAM (메모리) -> 16G / 32G etc..
# HDD

'''
process -----
RAM 에서 프로그램마다 메모리를 할당한다.
파이썬은 할당된 메모리를 관리한다.

-------------

python memory model -----
1. frame(stack)
- n1 이라는 변수에 object 의 주소값이 저장됨 (heap 에서 만들어짐) ex id(n1) = 140728543310096
- n2 이라는 변수에 n1과 같은 주소값이 저장됨 ex id(n2) = 140728543310096

2. 객체(heap)
- object 의 실제값 ex 1 (주소 = 140728543310096)
- object 의 실제값 ex 2 (주소 = 140728713310512)

참조한다(reference) : 변수가 객체를 찾아간다.(주소를 찾아간다)
---------------------------

'''
n1 = 1  # object : 객체 : 실제로 존재하는 것 : like 물
#n1     # 변수 : like 물을 담는 컵
print(f'주소 = {id(n1)}, 저장된 값 = {n1}') # id(n1) = 140728713310480
n2 = n1 # n1의 주소를 n2에 저장함
print(f'주소 = {id(n2)}, 저장된 값 = {n2}') # id(n2) = 140728713310480 n1과 같다!

# if n2 = 2라고 바꾸면
n2 = 2  # 컵은 그대로 있으나 없던 객체 2가 생겨 heap 에 새로운 객체 2가 생긴다.
print(f'주소 = {id(n2)}, 저장된 값 = {n2}') # id(n2) = 140728713310512

# if n3 = 1일때에는?
n3 = 1
print(f'주소 = {id(n3)}, 저장된 값 = {n3}') # id(n3) = 140728713310480 주소값이 n1와 같다! n1=n3해주지 않았는데도 불구하고!
# 숫자와 문자열인 경우 생성된 객체를 캐싱함(재활용함)
# how? 파이썬이 객체를 관리하고 있어서 새로운 객체(숫자)를 만들지 않고 주소를 변수에 주는 것.

# if n3 = 3 - 1 : 3이라는 숫자가 새로 생기고, - 1한다면?
n3 = 3 - 1
print(f'주소 = {id(n3)}, 저장된 값 = {n3}') # id(n3) = 140728543310128 주소값이 n2와 같다! 3 - 1 = 2라는 값이 heap 에 있으므로 2 주소를 재활용

# 숫자와 문자열을 제외한 다른 모든 객체들은 값이 사용할 때마다 새로 생성됨 (출력할 때마다 다름)
list1 = [1, 2, 3]
print(f'주소 = {id(list1)}, 저장된 값 = {list1}') # id(list1) = 2949758014024

list2 = [1, 2, 3]
print(f'주소 = {id(list2)}, 저장된 값 = {list2}') # id(list2) = 2949758014536 값은 같으나 주소값은 다르다!
# 기존 리스트를 재활용하지 않고, 새로운 리스트를 생성한다.




# 함수의 parameter 를 stack과 heap의 관점에서 보자.
# 예시
list3 = list1 # 새로운 cup을 만든다. stack 영역에 새로운 변수 list3을 만들고 주소를 list1으로 준다.
print(f'주소 = {id(list3)}, 저장된 값 = {list3}') # id(list3) = 2949758014024 id(list1)과 같다!

# 중요! if list1을 바꾸면 list3도 값이 바뀔까?
list1[0] = 100
print(f'주소 = {id(list1)}, 저장된 값 = {list1}')
print(f'주소 = {id(list3)}, 저장된 값 = {list3}') # id(list3) = 2949758014024 id(list1)과 같으므로 list1의 값이 바뀐 id(list1)을 출력

# 논리
# 함수 정의 - 함수(parameter):
# 함수 호출 - 함수(argument)
# 함수 호출한다 = 값(argument)를 함수 선언할 때 만들어준 변수(argument)에 저장한다.
# stack 에 새로운 object 가 생기고 argument 가 가지고 있었던 주소가 할당된다.
# numbers_copy = numbers 의미 : numbers 의 주소를 numbers_copy 에 할당한다.
# numbers_copy = numbers.copy() 의미 : numbers의 값을 복사하여 새로운 객체를 만든다. ex_ list1 = [1, 2, 3], list2 = [1, 2, 3]




# == 연산자 VS is 연산자
a = [1, 2, 3]
b = [1, 2, 3]
print(f'==: {a == b}, is: {a is b}') # ==: True, is: False
# why? is: False - is
# ==: True 두 변수가 참조하는 객체의 값이 같은지 비교 즉, 실제 값들을 비교해서 같다를 판별
# is: False 두 변수에 저장된 주소를 비교 즉, a의 주소와 b의 주소를 비교해서 같다를 판별
# 숫자와 문자열은 주소를 재활용하기 때문에 값도 같고 주소도 같겠지만, 다른 객체들은 그렇지 않다!